<head>
<title>yacc(1) - Plan 9 from User Space</title>
<meta content="text/html; charset=utf-8" http-equiv=Content-Type>
</head>
<body bgcolor=#ffffff>
<table border=0 cellpadding=0 cellspacing=0 width=100%>
<tr height=10><td>
<tr><td width=20><td>
<tr><td width=20><td><b>YACC(1)</b><td align=right><b>YACC(1)</b>
<tr><td width=20><td colspan=2>
    <br>
<p><font size=+1><b>NAME     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    yacc &ndash; yet another compiler-compiler<br>
    
</table>
<p><font size=+1><b>SYNOPSIS     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    <tt><font size=+1>yacc</font></tt> [ <i>option ...</i> ] <i>grammar<br>
    </i>
</table>
<p><font size=+1><b>DESCRIPTION     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    <i>Yacc</i> converts a context-free grammar and translation code into
    a set of tables for an LR(1) parser and translator. The grammar
    may be ambiguous; specified precedence rules are used to break
    ambiguities. 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    The output file, <tt><font size=+1>y.tab.c</font></tt>, must be compiled by the C compiler to
    produce a program <tt><font size=+1>yyparse</font></tt>. This program must be loaded with a
    lexical analyzer function, <tt><font size=+1>yylex(void)</font></tt> (often generated by <i>lex</i>(1)),
    with a <tt><font size=+1>main(int argc, char *argv[])</font></tt> program, and with an error
    handling routine, <tt><font size=+1>yyerror(char*)</font></tt>. 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    The options are<br>
    <tt><font size=+1>&#8722;o</font></tt> <i>output</i>&nbsp;&nbsp;&nbsp;Direct output to the specified file instead of <tt><font size=+1>y.tab.c</font></tt>.<br>
    <tt><font size=+1>&#8722;D</font></tt><i>n</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create file <tt><font size=+1>y.debug</font></tt>, containing diagnostic messages. To incorporate
    them in the parser, compile it with preprocessor symbol <tt><font size=+1>yydebug</font></tt>
    defined. The amount of diagnostic output from the parser is regulated
    by value <i>n</i>. The value 0 reports errors; 1 reports reductions;
    higher values (up to 4) include more information about state transitions.
    <tt><font size=+1>&#8722;v</font></tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create file <tt><font size=+1>y.output</font></tt>, containing a description of the parsing
    tables and of conflicts arising from ambiguities in the grammar.<br>
    <tt><font size=+1>&#8722;d</font></tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create file <tt><font size=+1>y.tab.h</font></tt>, containing <tt><font size=+1>#define</font></tt> statements that associate
    <i>yacc</i>-assigned &#8216;token codes&#8217; with user-declared &#8216;token names&#8217;.
    Include it in source files other than <tt><font size=+1>y.tab.c</font></tt> to give access to
    the token codes.<br>
    <tt><font size=+1>&#8722;s</font></tt> <i>stem</i>&nbsp;&nbsp;&nbsp;&nbsp;Change the prefix <tt><font size=+1>y</font></tt> of the file names <tt><font size=+1>y.tab.c</font></tt>, <tt><font size=+1>y.tab.h</font></tt>,
    <tt><font size=+1>y.debug</font></tt>, and <tt><font size=+1>y.output</font></tt> to <i>stem</i>.<br>
    <tt><font size=+1>&#8722;S</font></tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write a parser that uses Stdio instead of the <tt><font size=+1>print</font></tt> routines
    in libc.<br>
    <tt><font size=+1>&#8722;l</font></tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disable #line directives in the generated parser.<br>
    <tt><font size=+1>&#8722;a</font></tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a parser that takes an argument of type Yyarg and passes
    this argument to each invocation of the lexer function, yylex.
    Yyarg contains per-instance state and a single user-visible member,
    arg, of type void*. 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    The specification of <i>yacc</i> itself is essentially the same as the
    UNIX version described in the references mentioned below. Besides
    the <tt><font size=+1>&#8722;D</font></tt> option, the main relevant differences are:<br>
    
    <table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

        The interface to the C environment is by default through <tt><font size=+1>&lt;libc.h&gt;</font></tt>
        rather than <tt><font size=+1>&lt;stdio.h&gt;</font></tt>; the <tt><font size=+1>&#8722;S</font></tt> option reverses this.<br>
        The parser accepts UTF input text (see <a href="../man7/utf.html"><i>utf</i>(7)</a>), which has a couple
        of effects. First, the return value of <tt><font size=+1>yylex()</font></tt> no longer fits
        in a <tt><font size=+1>short</font></tt>; second, the starting value for non-terminals is now
        0xE000 rather than 257.<br>
        The generated parser can be recursive: actions can call <i>yyparse</i>,
        for example to implement a sort of <tt><font size=+1>#include</font></tt> statement in an interpreter.<br>
        Finally, some undocumented inner workings of the parser have been
        changed, which may affect programs that know too much about its
        structure.<br>
        
    </table>
    
</table>
<p><font size=+1><b>FILES     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    <tt><font size=+1>y.output<br>
    y.tab.c<br>
    y.tab.h<br>
    y.debug<br>
    y.tmp.*</font></tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temporary file<br>
    <tt><font size=+1>y.acts.*</font></tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temporary file<br>
    <tt><font size=+1><a href="/usr/local/plan9/lib/yaccpar">/usr/local/plan9/lib/yaccpar</a><br>
    </font></tt>
    <table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

        
        <table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

            parser prototype<br>
            
        </table>
        
    </table>
    <tt><font size=+1><a href="/usr/local/plan9/lib/yaccpars">/usr/local/plan9/lib/yaccpars</a><br>
    </font></tt>
    <table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

        
        <table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

            parser prototype using stdio<br>
            
        </table>
        
    </table>
    
</table>
<p><font size=+1><b>SOURCE     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    <tt><font size=+1><a href="/usr/local/plan9/src/cmd/yacc.c">/usr/local/plan9/src/cmd/yacc.c</a><br>
    </font></tt>
</table>
<p><font size=+1><b>SEE ALSO     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    <i>lex</i>(1)<br>
    S. C. Johnson and R. Sethi, &#8220;Yacc: A parser generator&#8221;, <i>Unix Research
    System Programmer&#8217;s Manual,</i> Tenth Edition, Volume 2<br>
    B. W. Kernighan and Rob Pike, <i>The UNIX Programming Environment,</i>
    Prentice Hall, 1984<br>
    
</table>
<p><font size=+1><b>BUGS     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    The parser may not have full information when it writes to <tt><font size=+1>y.debug</font></tt>
    so that the names of the tokens returned by <tt><font size=+1>yylex</font></tt> may be missing.<br>
    
</table>

<td width=20>
<tr height=20><td>
</table>
<!-- TRAILER -->
<table border=0 cellpadding=0 cellspacing=0 width=100%>
<tr height=15><td width=10><td><td width=10>
<tr><td><td>
<center>
<a href="https://9fans.github.io/plan9port/"><img src="../../dist/glendacircle.png" alt="Space Glenda" border=0></a>
</center>
</table>
<!-- TRAILER -->
</body></html>
