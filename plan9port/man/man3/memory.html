<head>
<title>memory(3) - Plan 9 from User Space</title>
<meta content="text/html; charset=utf-8" http-equiv=Content-Type>
</head>
<body bgcolor=#ffffff>
<table border=0 cellpadding=0 cellspacing=0 width=100%>
<tr height=10><td>
<tr><td width=20><td>
<tr><td width=20><td><b>MEMORY(3)</b><td align=right><b>MEMORY(3)</b>
<tr><td width=20><td colspan=2>
    <br>
<p><font size=+1><b>NAME     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    memccpy, memchr, memcmp, memcpy, memmove, memset &ndash; memory operations<br>
    
</table>
<p><font size=+1><b>SYNOPSIS     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    <tt><font size=+1>#include &lt;u.h&gt;<br>
    #include &lt;libc.h&gt; 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    </font></tt>
    <tt><font size=+1>void* memccpy(void *s1, void *s2, int c, long n) 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    </font></tt>
    <tt><font size=+1>void* memchr(void *s, int c, long n) 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    </font></tt>
    <tt><font size=+1>int &nbsp;&nbsp;&nbsp;memcmp(void *s1, void *s2, long n) 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    </font></tt>
    <tt><font size=+1>void* memcpy(void *s1, void *s2, long n) 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    </font></tt>
    <tt><font size=+1>void* memmove(void *s1, void *s2, long n) 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    </font></tt>
    <tt><font size=+1>void* memset(void *s, int c, long n)<br>
    </font></tt>
</table>
<p><font size=+1><b>DESCRIPTION     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    These functions operate efficiently on memory areas (arrays of
    bytes bounded by a count, not terminated by a zero byte). They
    do not check for the overflow of any receiving memory area. 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    <i>Memccpy</i> copies bytes from memory area <i>s2</i> into <i>s1</i>, stopping after
    the first occurrence of byte <i>c</i> has been copied, or after <i>n</i> bytes
    have been copied, whichever comes first. It returns a pointer
    to the byte after the copy of <i>c</i> in <i>s1</i>, or zero if <i>c</i> was not found
    in the first <i>n</i> bytes of <i>s2</i>. 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    <i>Memchr</i> returns a pointer to the first occurrence of byte <i>c</i> in
    the first <i>n</i> bytes of memory area <i>s,</i> or zero if <i>c</i> does not occur.
    
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    <i>Memcmp</i> compares its arguments, looking at the first <i>n</i> bytes only,
    and returns an integer less than, equal to, or greater than 0,
    according as <i>s1</i> is lexicographically less than, equal to, or greater
    than <i>s2</i>. The comparison is bytewise unsigned. 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    <i>Memcpy</i> copies <i>n</i> bytes from memory area <i>s2</i> to <i>s1</i>. It returns <i>s1</i>.
    
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    <i>Memmove</i> works like <i>memcpy</i>, except that it is guaranteed to work
    if <i>s1</i> and <i>s2</i> overlap. 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    <i>Memset</i> sets the first <i>n</i> bytes in memory area <i>s</i> to the value of
    byte <i>c</i>. It returns <i>s</i>.<br>
    
</table>
<p><font size=+1><b>SOURCE     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    All these routines have portable C implementations in <tt><font size=+1><a href="/usr/local/plan9/src/lib9">/usr/local/plan9/src/lib9</a></font></tt>.<br>
    
</table>
<p><font size=+1><b>SEE ALSO    </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    <a href="../man3/strcat.html"><i>strcat</i>(3)</a><br>
    
</table>
<p><font size=+1><b>BUGS     </b></font><br>

<table border=0 cellpadding=0 cellspacing=0><tr height=2><td><tr><td width=20><td>

    ANSI C does not require <i>memcpy</i> to handle overlapping source and
    destination; on Plan 9, it does, so <i>memmove</i> and <i>memcpy</i> behave
    identically. 
    <table border=0 cellpadding=0 cellspacing=0><tr height=5><td></table>
    
    If <i>memcpy</i> and <i>memmove</i> are handed a negative count, they abort.<br>
    
</table>

<td width=20>
<tr height=20><td>
</table>
<!-- TRAILER -->
<table border=0 cellpadding=0 cellspacing=0 width=100%>
<tr height=15><td width=10><td><td width=10>
<tr><td><td>
<center>
<a href="http://swtch.com/plan9port/"><img src="../../dist/glendacircle.png" alt="Space Glenda" border=0></a>
</center>
</table>
<!-- TRAILER -->
</body></html>
